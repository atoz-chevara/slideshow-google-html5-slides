<div class="slide transitionSlide" id="realtime-title">
  <section class="middle">
    <h2>Realtime / Communication</h2>
    <p>Stay connected</p>
    <img src="http://www.html5rocks.com/static/images/identity/classes_64/HTML5_Connectivity_64.png" title="HTML5 Realtime &amp; Communication" alt="HTML5 Realtime &amp; Communication">
  </section>
</div>


<div class="slide realtime-communication" id="web-workers">
  <header><span class="js">JS</span> <h1>Web Workers</h1></header>
  <section>
main.js:
<pre>
var worker = new <b>Worker</b>('task.js');
worker.<b>onmessage</b> = function(event) { alert(event.data); };
worker.<b>postMessage</b>('data');
</pre>
task.js:
<pre>
self.<b>onmessage</b> = function(event) {
// Do some work.
self.<b>postMessage</b>("recv'd: " + event.data);
};
</pre>

<div id="w-wrapper">
  <div id="wmap" class="gmap example">
    <img src="http://maps.google.com/maps/api/staticmap?center=13,13&zoom=3&size=680x200&sensor=false"/>
  </div>
  <div style="margin-top:5px">
    <button id="find-route-y">Find route with Workers</button>
    <button id="find-route-n">Find route without Workers</button>
    <p id="w-loading">Loading Route...</p>
  </div>
  <p style="font-size: 90%;" class="center">Try dragging the map while the complex route is being calculated (you will only be able to do that with Workers!)</p>
</div>
<script src="src/webworkers/points.js" defer></script>
<script src="src/webworkers/annealing.js" defer></script>
<script defer>
(function() {
  var markersArray = [];
  var map = null;
  var useThreads = false;

  document.querySelector('#w-wrapper').addEventListener('click', function(event) {
    if (!map) {
      map = new google.maps.Map(document.querySelector('#wmap'), {
        zoom: 3,
        center: new google.maps.LatLng(13, 13),
        mapTypeId: google.maps.MapTypeId.ROADMAP
      });
      map.getDiv().style.border =  '1px solid #ccc';
      drawPoints();
    }

    if (event.target.id == 'find-route-y') {
      useThreads = true;
      document.querySelector('#w-loading').style.visibility = 'visible';
      test();
    } else if (event.target.id == 'find-route-n'){
      useThreads = false;
      document.querySelector('#w-loading').style.visibility = 'visible';
      // this setTimout is so that we see the 'loading' label
      setTimeout(function() { test(); }, 10);
    }
  }, false);

  function drawPath(path) {
    var firstPoint = true;
    var l = p1.length;
    var scaleFactor = 5;
    for (var i = 0; i < l - 1; ++i) {
      var points = [
        new google.maps.LatLng(p1[i].x / scaleFactor,
                               p1[i].y / scaleFactor),
        new google.maps.LatLng(p1[i + 1].x / scaleFactor,
                               p1[i + 1].y / scaleFactor)
      ];
      var polyline = new google.maps.Polyline(
          {path: points, strokeColor: '#ff0000', strokeWeight: 1});
      markersArray.push(polyline);
      polyline.setMap(map);
    }
  }

  function drawPoints() {
    var blueIcon = new google.maps.MarkerImage(
        'src/webworkers/point.png',
        new google.maps.Size(3, 3), // size
        new google.maps.Point(0, 0), // origin
        new google.maps.Point(0, 0)); // anchor
    for (var i = 0; i < p1.length; ++i) {
      // Render in Gmap instead of canvas
      var point = new google.maps.LatLng(p1[i].x / 5, p1[i].y / 5);
      var marker = new google.maps.Marker({
          position: point, icon: blueIcon, map: map});
      markersArray.push(marker);
    }
  }

  function deleteOverlays() {
    if (markersArray) {
      for (var i in markersArray) {
        markersArray[i].setMap(null);
      }
      markersArray = [];
    }
  }

  function test() {
    var name = "Test 1";
    var self = this;
    deleteOverlays();
    drawPoints();
    setTimeout(function() {
      var opts = {
        points: p1,
        t0: 1,
        g: 0.99,
        stepsPerT: 10
      };
      var callback = {
        name: name,
        newMin: function(p) {
        },
        draw: function(p) {
          document.querySelector('#w-loading').style.visibility = 'hidden';
          drawPath(p);
        }
      };
      var a;
      if (useThreads) {
        var worker = new Worker('src/webworkers/Worker.js')
        worker.onmessage = function(event) {
          var returnedData = JSON.parse(event.data);
          var msg = returnedData[0];
          var p = returnedData[1];
          callback[msg](p);
        };
        worker.onerror = function(event) {
          console.log(event);
        };
        worker.postMessage(JSON.stringify({
          opts: opts,
          width: 200,
          height: 200
        }));
      } else {
        var annealing = new Annealing();
        var callback2 = {
          onNewMin: function(p) {
            // postMessage('newmin')
          },
          onDone: function(p) {
            document.querySelector('#w-loading').style.visibility = 'hidden';
            drawPath(p);
          }
        };
        annealing.init(opts, opts.width, opts.height, callback2);
        annealing.go();
      }
    }, 10);
  }
})();
</script>
</section>
</div>


<div class="slide realtime-communication" id="web-sockets">
  <header><span class="js">JS</span> <h1>WebSocket</h1></header>
  <section>
<pre>var socket = new <b>WebSocket</b>('ws://html5rocks.websocket.org/echo');
socket.<b>onopen</b> = function(event) {
socket.<b>send</b>('Hello, WebSocket');
};
socket.<b>onmessage</b> = function(event) { alert(event.data); }
socket.<b>onclose</b> = function(event) { alert('closed'); }
</pre>

    <p id="websockets-message">Full-duplex, bi-directional communication over the Web:
    Both the server and client can send data at any time, or even at the same time.
    Only the data itself is sent, without the overhead of HTTP headers, dramatically
    reducing bandwidth.</p>

    <div id="ws-left">
      Use the echo demo below to test a WebSocket connection from your browser.
      Both the message you send and the response you receive travel over the same WebSocket connection.

      <div id="ws-config-location">
        <h4>Location:</h4>
        <input type="text" id="wsUri" disabled />
        <br>
        <input type="checkbox" id="wsSecureCb" onclick="wsToggleTls();" disabled />
        <label id="wsSecureCbLabel" for="wsSecureCb">Use secure WebSocket (TLS/SSL)</label>
        <br>
        <button id="wsConnectBut" disabled>Connect</button>
        <button id="wsDisconnectBut" disabled>Disconnect</button>
      </div>
      <div id="ws-config-message">
        <h4>Message:</h4>
        <input  type="text" id="wsMessage" value="Hello, WebSocket" disabled />
        <button id="wsSendBut" disabled>Send</button>
      </div>
    </div>
    <div id="ws-right">
      <div id="ws-log">
        <strong>Output:</strong>
        <div id="wsConsoleLog"></div>
        <button id="wsClearLogBut">Clear log</button>
      </div>
    </div>
    <div id="ws-powered">
      Demo powered by <a href="http://kaazing.com" target="_blank"><img id="wsKaazingLogo" src="src/websocket/kaazing-logo_99x16.png" width="99" height="16" alt="Powered by Kaazing" /></a>
    </div>

  </section>
  <script src="src/websocket/websocket.js" defer></script>
</div>


<div class="slide realtime-communication" id="notifications-api">
  <header><span class="js">JS</span> <h1>Notifications</h1></header>
  <section>
<pre>if (window.<b>webkitNotifications</b>.<b>checkPermission</b>() == 0) {
// you can pass any url as a parameter
window.<b>webkitNotifications</b>.<b>createNotification</b>(tweet.picture, tweet.title,
tweet.text).<b>show</b>();
} else {
window.<b>webkitNotifications</b>.<b>requestPermission</b>();
}
</pre>
<div id="notifications-message">
  <p>
    <button id="request-permission" href="#">Set notification permissions for this page</button>
  </p>
  <p>Note: Use this button if you also want to <em>reset</em> the permissions</p>

  <br>
  <p>Enter your twitter user name to show your last tweet as a notification</p>
  <input type="text" id="username" placeholder="username" />
  <button id="show-tweets">Show tweet notifications</button>
</div>

  <script defer>
  document.getElementById('request-permission').addEventListener('click', function() {
    window.webkitNotifications.requestPermission();
  }, false);

  document.getElementById('show-tweets').addEventListener('click', function() {
    readTweets();
  }, false);

  function readTweets() {
    var username = document.getElementById('username').value;
    if (username == 'username') {
      alert('Enter a username first');
      return;
    }
    var script = document.createElement("script");
    script.src = 'http://twitter.com/statuses/user_timeline/'+ username+'.json?count=1&callback=fetchTweets';
    document.body.appendChild(script);
  }

  function fetchTweets(data) {
    var tweet;
    var i = data.length;
    while (i--) {
      tweet = data[i];
      if (window.webkitNotifications.checkPermission() == 0) {
        // note the show()
        window.webkitNotifications.createNotification(tweet.user.profile_image_url, tweet.user.name, tweet.text).show();
      } else {
        // Note that we can't call requestPermission from here as we are in the callback function and not triggered just on user action
        alert('You have to click on "Set notification permissions for this page" first to be able to receive notifications.');
        return;
      }
    }
  }
  </script>

  </section>
</div>
